---
title: "Learning Java: Begineer's guide - Day 6"
subtitle: "java-learning-day6"
date: "2023-04-08"
summary: "Learning Java and its data structures and algorithms"
tags: ["Java", "Learning"]
---

## Recap of Previous Lecture

In our last lecture, we focused on methods and classes in Java. We explored how to create and use methods, including defining them with the correct syntax, specifying parameters, and returning values. We also discussed method overloading and the importance of the 'this' keyword.

Furthermore, we delved into classes, discussing how they act as blueprints for creating objects. We covered the basics of object-oriented programming, including constructors, object instances, and the use of inheritance to create a hierarchy of classes. We also touched upon the concepts of abstraction, encapsulation, polymorphism, and inheritance.

## What We Will Learn Today

In today's lecture, we will continue to expand our Java programming knowledge by focusing on the following topics:

1. Abstract classes and methods
2. Interfaces
3. Nested classes
4. Generics
5. Lambda expressions
6. Reflection
7. Annotations

These advanced Java concepts will enable you to write more complex and flexible programs, enhancing your programming expertise in this versatile language.

## Introduction

Building on our foundation in Java methods and classes, today's lecture will take us deeper into the world of Java programming. We'll explore abstract classes and methods, interfaces, nested classes, generics, lambda expressions, reflection, and annotations. By mastering these advanced topics, you'll be better equipped to tackle sophisticated Java programs and applications. Let's dive in and continue expanding our Java programming knowledge.

## Abstract Classes and Methods

In object-oriented programming, abstraction is a powerful technique that allows us to model real-world entities while hiding unnecessary details. Abstract classes and methods are key components in achieving abstraction in Java.

An abstract class serves as a blueprint for creating more specific classes, known as subclasses. It is designed to be extended, which means you cannot create an instance of an abstract class directly. Instead, you create instances of its subclasses. Abstract classes often contain abstract methods, which are methods without a body, and are meant to be overridden and implemented by the subclasses.

Abstract classes can also have concrete methods, which provide default behavior that can be inherited by the subclasses.

### When to Use Abstract Classes and Methods

Abstract classes and methods are useful when:

1. You have a group of related classes with common functionality that you want to extract and share.
2. You want to provide a high-level blueprint for a group of classes, ensuring that they adhere to a specific structure or contract.
3. You want to prevent the instantiation of a class that should only be extended.

### Defining an Abstract Class

```java
abstract class Animal {
    abstract void makeSound();

    void sleep() {
        System.out.println("The animal is sleeping.");
    }
}
```

In this example, the Animal class is abstract and contains an abstract method makeSound() and a concrete method sleep().

### Defining an Abstract Method

Abstract methods are methods without a body, declared using the abstract keyword before the method signature. They must be implemented by any non-abstract subclass of the abstract class. In our example, the makeSound() method is an abstract method.


### Extending an Abstract Class

To create a concrete class that extends an abstract class, use the extends keyword followed by the abstract class name. The concrete class must provide an implementation for all abstract methods in the abstract class.


```java
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("The dog barks.");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("The cat meows.");
    }
}
```

In this example, the Dog and Cat classes extend the Animal abstract class and provide their own implementation of the makeSound() method.

### Using an Abstract Class

You cannot create an instance of an abstract class directly. However, you can create instances of its subclasses and use them as if they were instances of the abstract class. This is known as polymorphism.

```java
public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myDog.makeSound(); // Output: The dog barks.
        myDog.sleep();     // Output: The animal is sleeping.

        myCat.makeSound(); // Output: The cat meows.
        myCat.sleep();     // Output: The animal is sleeping.
    }
}
```

In this example, we create instances of the Dog and Cat classes and use them through an Animal reference. This allows us to call the makeSound() and sleep() methods on both instances.

## Interfaces

## Nested classes

## Generics

## Lambda expressions

## Reflection

## Annotations
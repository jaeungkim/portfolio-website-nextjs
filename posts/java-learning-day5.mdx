---
title: "Learning Java: Begineer's guide - Day 5"
subtitle: "java-learning-day5"
date: "2023-04-05"
summary: "Learning Java and its data structures and algorithms"
tags: ["Java", "Learning"]
---

## Recap of Previous Lecture

In the previous lecture, we learned about loops in Java, including the for loop, while loop, and do-while loop. We discussed how to set loop conditions, declare loop variables, perform actions within the loop, and avoid common mistakes.

## What We Will Learn Today

In today's lecture, we will continue to build on these fundamentals and explore some new concepts related to Java programming. Specifically, we will focus on arrays, methods, and classes.

We will start by learning about arrays, which are used to store multiple values of the same data type in a single variable. We will discuss how to declare and initialize arrays, access individual elements, and perform operations on array elements.

Next, we will explore methods, which are blocks of code that perform specific tasks and can be called from other parts of the program. We will learn how to define and call methods, pass arguments to methods, and return values from methods.

Finally, we will discuss classes, which are templates for creating objects that encapsulate data and behavior. We will learn how to define classes, create objects from classes, and access object properties and methods.

By the end of this lecture, you will have a better understanding of how to use arrays, methods, and classes in Java to create more complex and powerful programs.

## Introduction

Welcome to today's lecture on Java programming! In this lecture, we will dive deeper into some of the core concepts and features of Java, including arrays, methods, and classes. These topics are essential for building more complex and powerful programs in Java, and will help you become a more skilled and versatile Java programmer. So, let's get started!

## Arrays

Arrays are a fundamental data structure in Java, and are used to store multiple values of the same type in a single variable. Arrays are especially useful when we need to work with large amounts of data or when we need to perform the same operation on a group of values.

To declare an array in Java, we specify the type of the elements in the array, followed by a pair of square brackets []. For example, to declare an array of integers, we would use the following syntax:

```java
int[] numbers;
```

Once we have declared an array, we need to initialize it by specifying the number of elements in the array and the values of those elements. We can do this using an array initializer, which is a comma-separated list of values enclosed in curly braces {}. For example, to initialize an array of integers with the values 1, 2, 3, and 4, we would use the following syntax:

```java
int[] numbers = {1, 2, 3, 4};
```

We can access the elements of an array using their index, which is a zero-based integer that represents the position of the element in the array. For example, to access the first element of the array, we would use the following syntax:

```java
int firstNumber = numbers[0];
```

We can also modify the values of the elements in an array by assigning new values to them using their index. For example, to change the value of the second element in the array to 5, we would use the following syntax:

```java
numbers[1] = 5;
```

or you can declare the size of an array and input the variables later too

```java
int[] numbers = new int[5];
numbers = new int[]{1, 2, 3, 4, 5};
```

Arrays can be used in conjunction with loops to perform operations on all of the elements in the array. For example, to print out all of the elements in myArray, you could use a for loop like this:

```java
for (int i = 0; i < myArray.length; i++) {
    System.out.println(myArray[i]);
}
```

This loop iterates over all of the elements in myArray and prints each element to the console.

Arrays can also be multidimensional, meaning that they have multiple dimensions or levels. For example, a two-dimensional array is an array of arrays. To declare a two-dimensional array in Java, you use the following syntax:

```java
int[][] myArray = new int[3][3];
```

This creates a two-dimensional array with 3 rows and 3 columns. You can access elements in a two-dimensional array using two indexes, one for the row and one for the column. For example:

```java
int element = myArray[1][2];
```

This accesses the element at row 1, column 2 in the two-dimensional array.

2D arrays are useful for storing and manipulating data that has a natural structure with multiple dimensions. For example, you might use a 2D array to represent a game board or a matrix of numbers.

Here's an example of how you could use a 2D array to represent a tic-tac-toe game board:

```java
char[][] board = {
    {' ', ' ', ' '},
    {' ', ' ', ' '},
    {' ', ' ', ' '}
};
```

This creates a 2D array with 3 rows and 3 columns, initialized with spaces to represent an empty tic-tac-toe board. You can modify the elements of the array to represent moves made by the players.

Here's another example of how you could use a 2D array to represent a grayscale image:

```java
int[][] pixels = {
    {128, 128, 128, 255},
    {64, 64, 64, 255},
    {192, 192, 192, 255},
    {0, 0, 0, 255}
};
```

This creates a 2D array with 4 rows and 4 columns, where each element represents a pixel in a grayscale image. Each element is an array of integers representing the red, green, blue, and alpha (transparency) values of the pixel.

Here is some advanced example of using 2D array in problem solving.

I've created a sudoku solver.

```java
public class SudokuSolver {
    private int[][] board;

    public SudokuSolver(int[][] board) {
        this.board = board;
    }

    public boolean solveSudoku() {
        int row = -1;
        int col = -1;
        boolean isEmpty = true;

        // Find an empty cell
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == 0) {
                    row = i;
                    col = j;

                    // We still have an empty cell
                    isEmpty = false;
                    break;
                }
            }

            if (!isEmpty) {
                break;
            }
        }

        // If all cells are filled, the puzzle is solved
        if (isEmpty) {
            return true;
        }

        // Try values from 1 to 9 in the empty cell
        for (int num = 1; num <= 9; num++) {
            if (isValid(row, col, num)) {
                board[row][col] = num;

                // Recursively try to solve the puzzle
                if (solveSudoku()) {
                    return true;
                } else {
                    // Backtrack and try a different number
                    board[row][col] = 0;
                }
            }
        }

        // Puzzle cannot be solved
        return false;
    }

    private boolean isValid(int row, int col, int num) {
        // Check row
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == num) {
                return false;
            }
        }

        // Check column
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == num) {
                return false;
            }
        }

        // Check 3x3 box
        int boxRow = row - row % 3;
        int boxCol = col - col % 3;

        for (int i = boxRow; i < boxRow + 3; i++) {
            for (int j = boxCol; j < boxCol + 3; j++) {
                if (board[i][j] == num) {
                    return false;
                }
            }
        }

        // Number is valid
        return true;
    }

    public void printBoard() {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] board = {
                {5, 3, 0, 0, 7, 0, 0, 0, 0},
                {6, 0, 0, 1, 9, 5, 0, 0, 0},
                {0, 9, 8, 0, 0, 0, 0, 6, 0},
                {8, 0, 0, 0, 6, 0, 0, 0, 3},
                {4, 0, 0, 8, 0, 3, 0, 0, 1},
                {7, 0, 0, 0, 2, 0, 0, 0, 6},
                {0, 6, 0, 0, 0, 0, 2, 8, 0},
                {0, 0, 0, 4, 1, 9, 0, 0, 5},
                {0, 0, 0, 0, 8, 0, 0, 7, 9}
        };
        SudokuSolver solver = new SudokuSolver(board);
        solver.solveSudoku();
        solver.printBoard();
    }
}
```

Above will output

```code
5 3 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 3
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 9
```

In this code, we have created a 2D array called board that represents a Sudoku puzzle. The numbers in the array represent the initial values of the puzzle, with zeros representing empty squares. We then call the solveSudoku function to solve the puzzle, and print the solved puzzle using the printBoard function.

The solveSudoku function uses a recursive backtracking algorithm to solve the puzzle. It starts by finding the next empty square in the puzzle (represented by a zero in the board array), and then tries all possible values (1-9) for that square. If a value is found that does not violate the Sudoku rules (no duplicate numbers in the same row, column, or 3x3 sub-grid), the function recursively calls itself to continue solving the puzzle. If a solution cannot be found with the current value, the function backtracks and tries a different value.

The printBoard function simply prints the solved puzzle to the console in a formatted manner, with each row on a new line and each column separated by a space.

This example demonstrates the power of 2D arrays and how they can be used to represent complex data structures such as a Sudoku puzzle. By manipulating the values in the array and using algorithms to solve the puzzle, we can use 2D arrays to solve a wide variety of problems in programming.

In addition to one- and two-dimensional arrays, Java also supports arrays with more than two dimensions, although these are less commonly used.

## Questions - Arrays

### Arrays and 2D Arrays in Java

1. How do you declare and initialize a one-dimensional array in Java?
2. What is the difference between a one-dimensional array and a two-dimensional array in Java?
3. Write a Java Program to find the length of a given array.

```java
int[] numbers = {4, 2, 7, 1, 8};
// Find the length of the 'numbers' array and print it
```

4. Write a Java Program to calculate the sum of all elements in an array.

```java
int[] numbers = {4, 2, 7, 1, 8};
// Calculate the sum of all elements in the 'numbers' array and print it
```

5. Write a Java Program to find the maximum and minimum values in an array.

```java
int[] numbers = {4, 2, 7, 1, 8};
// Find the maximum and minimum values in the 'numbers' array and print them
```

6. Write a Java program to reverse the elements of an array.

```java
int[] numbers = {4, 2, 7, 1, 8};
// Reverse the elements of the 'numbers' array and print the reversed array
```

7. Write a Java program to create a 2D array of size 3x3 and initialize it with the numbers 1 to 9.

```java
// Declare and initialize a 3x3 2D array with the numbers 1 to 9
// Print the 2D array
```

8. Write a Java program to calculate the sum of the elements of the main diagonal of a 3x3 2D array.

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
// Calculate the sum of the elements of the main diagonal and print it
```

9. Write a Java program to transpose a 2D array (i.e., swap rows with columns).

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
// Transpose the 'matrix' 2D array and print the transposed array
```

## Answers - Arrays

1. How do you declare and initialize a one-dimensional array in Java?

```java
// Declare an array of integers
int[] myArray;

// Initialize the array with specific values
myArray = new int[]{1, 2, 3, 4, 5};

// Alternatively, you can declare and initialize the array in one step
int[] myArray = {1, 2, 3, 4, 5};
```

2. What is the difference between a one-dimensional array and a two-dimensional array in Java?

A one-dimensional array is a linear data structure that stores a collection of elements of the same type in a contiguous block of memory. Each element can be accessed using a single index.

A two-dimensional array is an array of arrays, often represented as a matrix or a table. It stores elements in rows and columns, and each element can be accessed using two indices: one for the row and one for the column.

Here's an example of declaring and initializing a two-dimensional array in Java:

```java
// Declare a 2D array of integers
int[][] my2DArray;

// Initialize the 2D array with specific values
my2DArray = new int[][]{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Alternatively, you can declare and initialize the 2D array in one step
int[][] my2DArray = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

3. Write a Java Program to find the length of a given array.

```java
int[] numbers = {4, 2, 7, 1, 8};
// Find the length of the 'numbers' array and print it
System.out.println(numbers.length);
```

4. Write a Java Program to calculate the sum of all elements in an array.

```java
int[] numbers = {4, 2, 7, 1, 8};

// Calculate the sum of all elements in the 'numbers' array and print it

int sum = 0;
for(int i = 0 ; i < numbers.length; i++){
    sum += numbers[i];
}

System.out.println(sum);
```

5. Write a Java Program to find the maximum and minimum values in an array.

```java
int[] numbers = {4, 2, 7, 1, 8};

// Find the maximum and minimum values in the 'numbers' array and print them

int max = numbers[0];
int min = numbers[0];

for (int i = 0; i < numbers.length; i++) {
    if (numbers[i] > max) {
        max = numbers[i];
    }
    if (numbers[i] < min) {
        min = numbers[i];
    }
}

System.out.println("Maximum value: " + max);
System.out.println("Minimum value: " + min);

```

6. Write a Java program to reverse the elements of an array.

```java
int[] numbers = {4, 2, 7, 1, 8};

// Reverse the elements of the 'numbers' array and print the reversed array

int[] reversed = new int[numbers.length];

for (int i = 0; i < numbers.length; i++) {
    reversed[i] = numbers[numbers.length - 1 - i];
}

System.out.println("Reversed array: " + Arrays.toString(reversed));

```

7. Write a Java program to create a 2D array of size 3x3 and initialize it with the numbers 1 to 9.

```java
// Declare and initialize a 3x3 2D array with the numbers 1 to 9
// Print the 2D array

int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println();
}
```

8. Write a Java program to calculate the sum of the elements of the main diagonal of a 3x3 2D array.

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
// Calculate the sum of the elements of the main diagonal and print it

int sum = 0;

for (int i = 0; i < matrix.length; i++) {
    sum += matrix[i][i];
}

System.out.println("Sum of the main diagonal: " + sum);
```

9. Write a Java program to transpose a 2D array (i.e., swap rows with columns).

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Transpose the 'matrix' 2D array and print the transposed array

int[][] transposed = new int[matrix[0].length][matrix.length];

for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[0].length; j++) {
        transposed[j][i] = matrix[i][j];
    }
}

for (int i = 0; i < transposed.length; i++) {
    for (int j = 0; j < transposed[i].length; j++) {
        System.out.print(transposed[i][j] + " ");
    }
    System.out.println();
}
```

## Methods

Methods are a fundamental building block of Java programming. They are used to define a set of instructions that can be executed multiple times throughout the program, reducing code redundancy and promoting code reusability. In this blog, we will explore what methods are, how they work, and how to define and use them in Java.

## What are Methods in Java?

In Java, a method is a block of code that performs a specific task or set of tasks. They are a set of instructions that are executed in sequence when the method is called. Methods can be used to perform simple or complex operations and can take arguments and return values.

## Defining and Calling Methods

To define a method in Java, we use the following syntax:

```java
[access modifier] [static] [return type] [method name]([parameter list]) {
    // Method body
}
```

- The access modifier specifies the level of access to the method. The four access modifiers in Java are public, private, protected, and default.
- The static keyword is used to define a static method, which belongs to the class and not to a specific instance of the class.
- The return type specifies the data type of the value returned by the method. If the method does not return a value, we use the void keyword.
- The method name is the name of the method.
- The parameter list is a comma-separated list of input parameters to the method.

Let's define a simple method that takes two integers as input and returns their sum:

```java
public static int sum(int a, int b) {
    return a + b;
}
```

To call a method in Java, we use the method name followed by the argument list in parentheses:

```java
int result = sum(5, 7);
```

## Types of Methods

There are four types of methods in Java:

1. **Instance Methods**: These are non-static methods that belong to a specific instance of a class.

2. **Static Methods**: These are methods that belong to a class and not to a specific instance of the class. They can be called using the class name.

3. **Constructors**: These are special methods used to create new instances of a class.

4. **Getter and Setter Methods**: These are methods used to access and modify the private fields of a class.

## Instance Methods

Instance methods are methods that belong to a specific instance of a class. They can access and modify the instance variables of that class. To call an instance method, we need to create an object of that class and call the method using the object. Here's an example:

```java
public class Dog {
    private String name;
    private int age;

    public Dog(String name, int age) { //constructor
        this.name = name;
        this.age = age;
    }

    public void bark() {
        System.out.println(name + " is barking!");
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

In this example, we have a Dog class with three instance methods: bark(), setName(), and setAge(). The bark() method accesses the name variable to print out a message. The setName() and setAge() methods set the name and age variables, respectively.

To call these instance methods, we first need to create a Dog object and set its properties:

```java
Dog myDog = new Dog();
myDog.setName("Rufus");
myDog.setAge(3);
```

Then, we can call the bark() method on the myDog object:

```java
myDog.bark();  // Output: Rufus is barking!
```

### "This" keyword and Constructors

The "this" keyword is used to refer to the current instance of a class. In the "Dog" class, the "this" keyword is used in the constructor to set the initial values of the "name" and "age" properties for a new instance of the class.

The "this" keyword is also used in the "setName" and "setAge" methods to refer to the current instance of the "Dog" class. This allows these methods to update the properties of the current instance, rather than some other instance of the class.

he constructor is a special method that is used to create new instances of a class. In the "Dog" class, the constructor takes two arguments, a name and an age, and uses the "this" keyword to set the initial values of the "name" and "age" properties for the new instance.

When you create a new instance of the "Dog" class using the constructor, you can pass in values for the "name" and "age" properties. For example:

```java
Dog myDog = new Dog("Buddy", 3);
```

This creates a new instance of the "Dog" class with the name "Buddy" and age "3".

## Static Methods

Static methods are methods that belong to a class and not to a specific instance of the class. They can be called using the class name, and they cannot access the instance variables of the class. Static methods are often used for utility methods that don't depend on the state of a particular object. Here's an example:

```java
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }
}
```

In this example, we have a MathUtils class with two static methods: add() and multiply(). These methods do not depend on the state of any object and can be called using the class name:

```java
int sum = MathUtils.add(5, 7);
int product = MathUtils.multiply(3, 4);

```

## Constructors

Constructors are special methods used to create new instances of a class. They have the same name as the class and do not have a return type. Constructors are called when an object is created using the new keyword. Here's an example:

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

In this example, we have a Person class with a constructor that takes two parameters: name and age. When we create a new Person object, we need to pass in the name and age values:

```java
Person john = new Person("John", 30);
```

This will create a new Person object with the name "John" and age 30.

## Getter and Setter Methods

Getter and setter methods, also known as accessor and mutator methods, are methods used to access and modify the private fields of a class. They allow us to control how the fields are accessed and modified from outside the class. Here's an example:

```java
public class Car {
    private String make;
    private String model;
    private int year;

    public String getMake() {
        return make;
    }

    public void setMake(String make) {
        this.make = make;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.setMake("Toyota");
        System.out.println(car.getMake()); // Output: Toyota
    }
}
```

In this example, we've created a Car object called "car" and used the setter method "setMake()" to set the value of the "make" field to "Toyota". We then used the getter method "getMake()" to retrieve the value of the "make" field and print it to the console. The output is "Toyota".

## Method Overloading

Method overloading is a technique in Java that allows us to define multiple methods with the same name but different parameter lists. The Java compiler uses the parameter list to determine which method to call when the method is invoked.

When we call a method with arguments, the Java compiler searches for a method that matches the number and type of arguments passed. If there is an exact match, the compiler calls that method. If there is no exact match, the compiler looks for the closest match based on the parameter types and performs implicit conversions if necessary.

For example, let's say we have a method named sum() that takes two integers and returns their sum. If we want to add two doubles, we could define another sum() method that takes two doubles and returns their sum. Here's how we could do that:

```java
public static int sum(int a, int b) {
    return a + b;
}

public static double sum(double a, double b) {
    return a + b;
}
```

Now we can call the sum() method with either integers or doubles:

```java
int a = 5, b = 7;
double x = 5.0, y = 7.0;

System.out.println(sum(a, b)); // prints 12
System.out.println(sum(x, y)); // prints 12.0
```

In the first case, the sum(int a, int b) method is called, and in the second case, the sum(double a, double b) method is called.

Method overloading is a useful technique that allows us to write more readable and maintainable code. It also reduces the number of method names we need to remember, as we can use the same name for similar methods that perform different operations.

## Method Recursion

Method recursion is a technique in Java where a method calls itself to perform a specific task. Recursion is often used when solving complex problems that can be divided into smaller sub-problems. The method solves the problem by breaking it down into smaller sub-problems and then calling itself to solve those sub-problems.

Recursion involves two main parts: the base case and the recursive case. The base case is the simplest form of the problem that can be solved without recursion, and the recursive case is the part of the problem that is broken down into smaller sub-problems.

Here's an example of a recursive method that calculates the factorial of a given integer n:

```java
public static int factorial(int n) {
    if (n == 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

In the above example, the base case is when n is equal to 1, in which case the method returns 1. In the recursive case, the method calls itself with n - 1 as the argument and multiplies the result by n. This continues until the base case is reached.

Let's say we want to calculate the factorial of 5. We can call the factorial() method like this:

```java
System.out.println(factorial(5)); // prints 120
```

The method calls itself multiple times with decreasing values of n, and eventually reaches the base case when n is equal to 1. Then it returns 1, and the results are multiplied together to give us the final result of 120.

## Classes

In Java, a class is a blueprint or a template for creating objects that share common properties and behaviors. It defines a set of attributes and methods that an object of that class can have. A class encapsulates the data and behavior of an object, providing a way to organize and structure code.

## Creating a Class

To create a class in Java, we use the class keyword followed by the name of the class and the class body enclosed in curly braces {}. Here's an example of a basic class:

```java
public class Person {
    String name;
    int age;

    public void printInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
```

In this example, we've defined a class called Person with two attributes, name and age, and a method called printInfo() that prints the person's name and age to the console.

## Attributes

Attributes, also known as instance variables or fields, represent the state of an object. They are declared within the class body but outside of any methods. Attributes can be of any data type, including primitive types such as int, double, and boolean, and reference types such as String, arrays, and other objects. Here's an example:

```java
public class Circle {
    double radius;
    String color;

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

```

In this example, we've defined a class called Circle with two attributes, radius and color, and a method called getArea() that calculates the area of the circle.

## Methods in Class

Methods, also known as functions, represent the behavior of an object. They are defined within the class body and can access the attributes of the object. Methods can be of any return type, including void, primitive types, reference types, and other objects. Here's an example:

```java
public class BankAccount {
    private double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
        } else {
            System.out.println("Insufficient balance!");
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

In this example, we've defined a class called BankAccount with an attribute called balance and three methods: a constructor that sets the initial balance, a deposit() method that adds money to the balance, a withdraw() method that subtracts money from the balance, and a getBalance() method that returns the current balance.

## Access Modifiers

Access modifiers determine the level of access that other classes have to the attributes and methods of a class. There are four access modifiers in Java:

- public: The attribute or method can be accessed from any class.
- private: The attribute or method can only be accessed from within the same class.
- protected: The attribute or method can be accessed from within the same class or any subclass.
- default: The attribute or method can be accessed from within the same package.

We specify the access modifier before the attribute or method. Here's an example:

```java
public class Student {
    private String name;
    protected int age;
    double gpa;
    public String major;

    public Student(String name, int age, double gpa, String major) {
        this.name = name;
        this.age = age;
        this.gpa = gpa;
        this.major = major;
    }

    public String getName() {
        return name;
    }
}
```

In this example, we have a Student class with four attributes: name, age, gpa, and major. The access modifiers for these attributes are private, protected, default, and public, respectively.

We've also defined a constructor that takes four parameters: name, age, gpa, and major. The constructor initializes the attributes with the values passed in as arguments using the this keyword, which refers to the current object.

Finally, we have a getName() method that returns the value of the name attribute. This method is public, meaning it can be accessed from any class.

## Inheritance

Inheritance is a mechanism in Java that allows us to create a new class by extending an existing class. The new class, called the subclass or child class, inherits the attributes and methods of the existing class, called the superclass or parent class. The subclass can also add its own attributes and methods or override the ones inherited from the superclass.

Here's an example:

```java
public class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
    }
}

public class Student extends Person {
    private double gpa;
    private String major;

    public Student(String name, int age, double gpa, String major) {
        super(name, age);
        this.gpa = gpa;
        this.major = major;
    }

    public void study() {
        System.out.println(name + " is studying " + major + " and has a GPA of " + gpa + ".");
    }
}
```

In this example, we have a Person class with two attributes: name and age, and a sayHello() method that prints out a greeting. We've also defined a Student class that extends the Person class and adds two attributes: gpa and major, and a study() method that prints out information about the student's major and GPA.

The Student class inherits the name and age attributes and the sayHello() method from the Person class. It also has its own constructor that calls the superclass constructor using the super keyword, and its own study() method that adds new behavior.

## Polymorphism

Polymorphism is a concept in Java that allows objects of different classes to be treated as if they are objects of the same class. This is achieved through inheritance and method overriding.

Here's an example:

```java
public class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound.");
    }
}

public class Dog extends Animal {
    public void makeSound() {
        System.out.println("The dog barks.");
    }
}

public class Cat extends Animal {
    public void makeSound() {
        System.out.println("The cat meows.");
    }
}
```

In this example, we have three classes: Animal, Dog, and Cat. The Dog and Cat classes inherit the makeSound() method from the Animal class, but provide their own implementation of the method. When we create objects of these classes and call the makeSound() method, the appropriate implementation is called based on the type of the object.

```java
Animal animal1 = new Animal();
Dog dog1 = new Dog();
Cat cat1 = new Cat();

animal1.makeSound(); // prints "The animal makes a sound."
dog1.makeSound(); // prints "The dog barks."
cat1.makeSound(); // prints "The cat meows."
```

In Java, a class is a blueprint or a template for creating objects that share common properties and behaviors. Classes encapsulate the data and behavior of an object, providing a way to organize and structure code. We can create objects of a class by using the new keyword and passing in arguments to a constructor. Inheritance allows us to create specialized classes based on existing ones, and polymorphism allows objects of different classes to be treated as if they are of the same type.

## Questions - Methods and Classes

1. What is the difference between a static method and an instance method?
2. Write a Java class called Vehicle with instance methods startEngine() and stopEngine() that start and stop the vehicle's engine. The class should have an instance variable for the engine status.
3. Write a Java class called Rectangle with instance methods getArea() and getPerimeter() that calculate the area and perimeter of the rectangle. The class should have instance variables for the length and width of the rectangle.
4. Write a Java class called MathUtils with static methods add() and subtract() that add and subtract two numbers respectively. The methods should take two arguments and return the result.
5. Write a Java class called StringUtils with a static method reverse() that takes a string as input and returns the reversed string. For example, if the input string is "hello", the method should return "olleh".
6. Write a java class called Calculator with two instance methods named add and subtract that take two integer parameters and return their sum and difference, respectively, and static methods named multiply and divide that take two integer parameters and return their product and quotient, respectively.
7. Write two java classes called `Circle` and `GeometryUtility`. The Circle class should have a private instance variable radius and an appropriate constructor. It should also have instance methods for calculating the area and circumference of the circle. The GeometryUtility class should have static methods for calculating the area and circumference of a circle given its radius as an input parameter.
8. Write a java class called Student grades with the following.

- Private instance variables for the student's name and an array of integer grades.
- A constructor that takes a name and an array of grades as input parameters.
- An instance method that calculates the student's average grade.
- A static method that takes two Student objects as input parameters and returns the student with the higher average grade.

9. Write a java class called Temperature Conversion with the following.

- An instance method named celsiusToFahrenheit that takes a double representing a Celsius temperature and returns the equivalent Fahrenheit temperature.
- An instance method named fahrenheitToCelsius that takes a double representing a Fahrenheit temperature and returns the equivalent Celsius temperature.
- A static method named convertCelsiusToFahrenheit that takes a double representing a Celsius temperature and returns the equivalent Fahrenheit temperature.
- A static method named convertFahrenheitToCelsius that takes a double representing a Fahrenheit temperature and returns the equivalent Celsius temperature.

10. Write a java class called Bank Account with the following.

- Private instance variables for the account holder's name, account number, and balance.
- A constructor that takes the account holder's name and account number as input parameters and initializes the balance to 0.
- An instance method to deposit a specified amount into the account.
- An instance method to withdraw a specified amount from the account.
- A static method that takes two BankAccount objects as input parameters and transfers a specified amount from one account to the other.

## Answers - Methods and Classes

1. What is the difference between a static method and an instance method?

In Java, the main difference between a static method and a non-static method (also known as an instance method) is the way they are accessed and the context in which they operate.

- Accessing Methods

To call a non-static method, you need to create an instance of the class and call the method on that instance, like this:

```java
MyClass obj = new MyClass();
obj.nonStaticMethod();
```

On the other hand, you can call a static method directly on the class itself, without creating an instance of the class, like this:

```java
MyClass.staticMethod();
```

- Context of Execution

A non-static method operates on the instance of the class on which it is called. It has access to the instance variables and methods of that instance. When you call a non-static method, you are invoking it in the context of a particular instance of the class.

A static method, on the other hand, does not operate on any particular instance of the class. It is not tied to any instance variables or methods. Instead, it operates on the class itself. When you call a static method, you are invoking it in the context of the entire class, not a particular instance of the class.

Here's an example to illustrate the difference:

```java
public class MyClass {
    public static int staticMethod() {
        return 1;
    }

    public int nonStaticMethod() {
        return 2;
    }
}
```

In this example, staticMethod() is a static method and nonStaticMethod() is a non-static method. You can call staticMethod() like this:

```java
int result = MyClass.staticMethod();
```

And you can call nonStaticMethod() like this:

```java
MyClass obj = new MyClass();
int result = obj.nonStaticMethod();
```

To summarize, the main differences between static and non-static methods in Java are in how they are accessed and the context in which they operate. Static methods can be called directly on the class itself and do not operate on any particular instance of the class, while non-static methods require an instance of the class to be created and operate on the instance they are called on.

2. Write a Java class called Vehicle with instance methods startEngine() and stopEngine() that start and stop the vehicle's engine. The class should have an instance variable for the engine status.

```java
public class Vehicle {
    private boolean engineStatus;

    public void startEngine() {
        if (!engineStatus) {
            System.out.println("Starting engine...");
            engineStatus = true;
        } else {
            System.out.println("Engine is already started.");
        }
    }

    public void stopEngine() {
        if (engineStatus) {
            System.out.println("Stopping engine...");
            engineStatus = false;
        } else {
            System.out.println("Engine is already stopped.");
        }
    }
}
```

3. Write a Java class called Rectangle with instance methods getArea() and getPerimeter() that calculate the area and perimeter of the rectangle. The class should have instance variables for the length and width of the rectangle.

```java
public class Rectangle {
    private int length;
    private int width;

    public Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
    }

    public int getArea() {
        return length * width;
    }

    public int getPerimeter() {
        return 2 * (length + width);
    }
}
```

4. Write a Java class called MathUtils with static methods add() and subtract() that add and subtract two numbers respectively. The methods should take two arguments and return the result.

```java
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }

    public static int subtract(int a, int b) {
        return a - b;
    }
}
```

5. Write a Java class called StringUtils with a static method reverse() that takes a string as input and returns the reversed string. For example, if the input string is "hello", the method should return "olleh".

```java
public class StringUtils {
    public static String reverse(String str) {
        String reversed = "";
        for (int i = str.length() - 1; i >= 0; i--) {
            reversed += str.charAt(i);
        }
        return reversed;
    }
}
```

6. Write a java class called Calculator with two instance methods named add and subtract that take two integer parameters and return their sum and difference, respectively, and static methods named multiply and divide that take two integer parameters and return their product and quotient, respectively.

```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int subtract(int a, int b) {
        return a - b;
    }

    static int multiply(int a, int b) {
        return a * b;
    }

    static int divide(int a, int b) {
        return a / b;
    }
}
```

7. Write two java classes called `Circle` and `GeometryUtility`. The Circle class should have a private instance variable radius and an appropriate constructor. It should also have instance methods for calculating the area and circumference of the circle. The GeometryUtility class should have static methods for calculating the area and circumference of a circle given its radius as an input parameter.

```java
class Circle {
    private double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    double area() {
        return Math.PI * Math.pow(radius, 2);
    }

    double circumference() {
        return 2 * Math.PI * radius;
    }
}

class GeometryUtility {
    static double circleArea(double radius) {
        return Math.PI * Math.pow(radius, 2);
    }

    static double circleCircumference(double radius) {
        return 2 * Math.PI * radius;
    }
}
```

8. Write a java class called Student grades with the following.

- Private instance variables for the student's name and an array of integer grades.
- A constructor that takes a name and an array of grades as input parameters.
- An instance method that calculates the student's average grade.
- A static method that takes two Student objects as input parameters and returns the student with the higher average grade.

```java
class Student {
    private String name;
    private int[] grades;

    Student(String name, int[] grades) {
        this.name = name;
        this.grades = grades;
    }

    double averageGrade() {
        int sum = 0;
        for (int grade : grades) {
            sum += grade;
        }
        return (double) sum / grades.length;
    }

    static Student getHigherAverage(Student s1, Student s2) {
        return s1.averageGrade() > s2.averageGrade() ? s1 : s2;
    }
}
```

9. Write a java class called Temperature Conversion with the following.

- An instance method named celsiusToFahrenheit that takes a double representing a Celsius temperature and returns the equivalent Fahrenheit temperature.
- An instance method named fahrenheitToCelsius that takes a double representing a Fahrenheit temperature and returns the equivalent Celsius temperature.
- A static method named convertCelsiusToFahrenheit that takes a double representing a Celsius temperature and returns the equivalent Fahrenheit temperature.
- A static method named convertFahrenheitToCelsius that takes a double representing a Fahrenheit temperature and returns the equivalent Celsius temperature.

```java
class TemperatureConverter {
    double celsiusToFahrenheit(double celsius) {
        return (celsius * 9 / 5) + 32;
    }

    double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }

    static double convertCelsiusToFahrenheit(double celsius) {
        return (celsius * 9 / 5) + 32;
    }

    static double convertFahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }
}

```

10. Write a java class called Bank Account with the following.

- Private instance variables for the account holder's name, account number, and balance.
- A constructor that takes the account holder's name and account number as input parameters and initializes the balance to 0.
- An instance method to deposit a specified amount into the account.
- An instance method to withdraw a specified amount from the account.
- A static method that takes two BankAccount objects as input parameters and transfers a specified amount from one account to the other.

```java
class BankAccount {
    private String name;
    private String accountNumber;
    private double balance;

    BankAccount(String name, String accountNumber) {
        this.name = name;
        this.accountNumber = accountNumber;
        this.balance = 0;
    }

    void deposit(double amount) {
        balance += amount;
    }

    void withdraw(double amount) {
        balance -= amount;
    }

    static void transfer(BankAccount from, BankAccount to, double amount) {
        from.withdraw(amount);
        to.deposit(amount);
    }

    double getBalance() {
        return balance;
    }
}

```

## What We Will Learn Next

In the next lecture, we will continue to build on these fundamentals and explore some advanced concepts in Java programming. We'll begin by investigating abstract classes and methods, discussing their importance in providing a foundation for creating more specific subclasses. Next, we'll delve into interfaces, emphasizing their role in defining contracts between classes. Our journey will continue with nested classes, where we'll examine their various types and the benefits they offer. We'll then introduce generics, which enable us to write more flexible and reusable code. As we progress, we'll cover lambda expressions, a concise way to represent functional interfaces in Java, and reflection, a powerful technique that allows us to inspect and manipulate classes, methods, and fields at runtime. Finally, we'll touch upon annotations, discussing their significance in providing metadata for our code. By the end of the lecture, you will have a better understanding of these advanced Java concepts and be able to use them to write more complex programs in this versatile language.

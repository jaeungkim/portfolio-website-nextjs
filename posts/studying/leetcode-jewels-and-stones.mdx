---
title: "Jewels and Stones (Leetcode)"
subtitle: "Leetcode daily question (easy)"
date: "2023-03-19"
summary: "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels."
tags: ["Leetcode", "JavaScript", "Java" , "Easy"]
---

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

**Example 1:**

Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Example 2:

Input: jewels = "z", stones = "ZZ"
Output: 0

## APPROACH

Fairly simple 2D array problem, here are the steps I took

1. split each parameters string into array (Java = char array, JavaScript = string array)

```java
char[] jewelsArray = jewels.toCharArray();
char[] stonesArray = stones.toCharArray();
```

2. using for loop, loop over two iterations with i and j index. First one for jewels array and second one for stones array.

```java
for (int i = 0; i < jewelsArray.length; i++) {
    for (int j = 0; j < stonesArray.length; j++) {
        if (jewelsArray[i] == stonesArray[j]) {
            counter++;
        }
    }
}
```

3. increase counter when jewels array index matches with stones array index
4. return counter

## COMPLEXITY

**Time Complexity**
* The time complexity of this code is O(n^2) because it uses two nested loops to compare each element of the "jewelsArray" to each element of the "stonesArray". As the input size increases, the running time will increase exponentially.

**Space Complexity**
* The space complexity of this code is O(1) because it uses only constant extra space to store the counter variable.

## SOLUTION

```java
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        char[] jewelsArray = jewels.toCharArray();
        char[] stonesArray = stones.toCharArray();

        int counter = 0;

        for (int i = 0; i < jewelsArray.length; i++) {
            for (int j = 0; j < stonesArray.length; j++) {
                if (jewelsArray[i] == stonesArray[j]) {
                    counter++;
                }
            }
        }

        return counter;
    }
}
```

**JavaScript Solution**

```tsx
/**
 * @param {string} jewels
 * @param {string} stones
 * @return {number}
 */
var numJewelsInStones = function (jewels, stones) {
  let jewelsArray = jewels.split(""); //[a,A];
  let stonesArray = stones.split(""); //[a,A,A,b,b,b,b];

  let counter = 0;

  for (let i = 0; i < jewelsArray.length; i++) {
    for (let j = 0; j < stonesArray.length; j++) {
      if (jewelsArray[i] === stonesArray[j]) {
        counter++;
      }
    }
  }

  return counter;
};
```
## Optimize

We can further optimize the complexities to O(m*n)

```java
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count=0;
        for(char c:stones.toCharArray()){
            if(jewels.indexOf(c)!=-1) count++;
        }
        return count;
    }
}
```

In this solution, we use the indexOf method of the String class to check if a character in stones is present in jewels. This method has a time complexity of O(n) where n is the length of the jewels string. We use this method for each character in the stones string, giving a total time complexity of O(m*n) where m is the length of the stones string. Since the two strings are of different lengths, the time complexity can be simplified to O(n) where n is the length of the longer string.